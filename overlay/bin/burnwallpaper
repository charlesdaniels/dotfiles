#!/usr/bin/env bash

# .SCRIPTDOC

# This script burns information (configurable by editing the body of the sript)
# into an image (generally a wallpaper), and either writes out that image, or
# sets it as the wallpaper using ``feh``.

# .SYNTAX

# $1 . . . path to input image

# $2 . . . (optional) path to write output image to. If omitted, the output is
#          set using feh instead.

# .LICENSE
#
# Copyright (c) 2018, Charles Daniels
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its
#    contributors may be used to endorse or promote products derived from
#    this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# .ENDOC

#### helper methods ###########################################################

pct2pix () {
	# Accept an col,row coordinate (on $1, $2) as and integer percentage in
	# 0..100, convert this to an absolute pixel coordinate in the image and
	# output it comma-delimited (for easy consumption by convert).

	IMAGE_HEIGHT="$(identify -format "%h" "$INPUT")"
	IMAGE_WIDTH="$(identify -format "%w" "$INPUT")"

	ROW="$(echo "($IMAGE_HEIGHT  / 100) * $2" | bc)"
	COL="$(echo "($IMAGE_WIDTH / 100) * $1" | bc)"

	printf "%s,%s" $COL $ROW
}

vpad () {
	# Pad $1 with newlines until it is $2 many lines long.

	TEXT="$1"
	DESIRED_LENGTH="$2"
	CURRENT_LENGTH="$(echo -e "$TEXT" | wc -l)"
	DIFFERENCE="0"
	if [ "$DESIRED_LENGTH" -gt "$CURRENT_LENGTH" ] ; then
		# if the current length is shorter than the desired length,
		# then we calculate the difference
		DIFFERENCE="$(echo "$DESIRED_LENGTH - $CURRENT_LENGTH" | bc)"
	fi

	# we use '\n ' instead of just \n to prevent BASH from discarding the
	# blank lines during variable substitution.
	PADDING="$(for i in $(seq $DIFFERENCE) ; do echo -n "\n " ; done)"

	echo -e -n "$TEXT$PADDING"
}

draw () {
	# Generate a -draw argument to convert.
	#
	# $1 . . . horizontal position as a percentage in 0..100
	#
	# $2 . . . vertical position as a percentage in 0..100
	#
	# $3 . . . text

	printf "%s" "-draw "
	printf "%s" '"'
	printf "fill-opacity %s " $OPACITY
	printf "text "
	pct2pix $1 $2
	printf " '%s'" "$(echo -e -n "$3")"
	printf "%s" '"'
}


#### setup ####################################################################

set -u
set -e

if [ $# -lt 1 ] ; then
	echo "$(basename $0) [input] [output]" > /dev/stderr
	exit 1
fi

INPUT="$1"

OUTPUT="/tmp/$(uuidgen)"
OUTPUT_IS_TEMP="YES"
SET_WALLPAPER="YES"
if [ $# -eq 2 ] ; then
	# set the output file if it was provided
	OUTPUT="$2"
	# prevent the output from being deleted
	OUTPUT_IS_TEMP="NO"
	# prevent the output from being immediate set as the wallpaper
	SET_WALLPAPER="NO"

fi

# select the font file from the output of fc-list
FONT="$(fc-list  | grep -i deja | grep -i mono | grep -i book | cut -d: -f1)"

# TODO: this should be expressed as a percentage of image height
FONTSIZE=30

OPACITY=0.7
FILLCOLOR=white

CACHE_DIR="$HOME/.cache/burnwallpaper"
mkdir -p "$CACHE_DIR"

#### collect data to be displayed #############################################

# fetch a weather report from wttr.in. The sed command strips out terminal
# color codes, which `convert` does not understand. The second sed command
# escapes instances of the ` symbol, which can cause trouble when the
# convert command is executed with sh -c.

WEATHER_FILE="$CACHE_DIR/weather.txt"

# handle case where WEATHER_FILE does not exist
WEATHER_FILE_TIME=2000
if [ -e "$WEATHER_FILE" ] ; then
	WEATHER_FILE_TIME=$(stat "$WEATHER_FILE" -c %Y)
fi

WEATHER_FILE_AGE=$(expr $(date +%s) - $WEATHER_FILE_TIME)

# if the weather is more than 10 minutes out of date, fetch it again
if [ $WEATHER_FILE_AGE -gt 600 ] ; then

	echo "INFO: fetching weather... "
	WEATHER="$(curl -s wttr.in | sed 's/\x1B\[[0-9;]\+[A-Za-z]//g' | sed 's/`/\\`/g' | head -n 7)"
	if [ "$WEATHER" = "" ] ; then
		# handle network outage
		WEATHER="<network outage>"
	else
		# only store the weather if there was no network issue
		echo "$WEATHER" > "$WEATHER_FILE"
	fi
else
	echo "INFO: weather file is $WEATHER_FILE_AGE seconds old, which is still current"
	WEATHER="$(cat "$WEATHER_FILE")"
fi
WEATHER="$(vpad "$WEATHER" 9)"

# We eliminate entries for snaps, as this produces too many lines of output
echo "INFO: generating block device listing... "
BLK="$(lsblk | grep -v '\/snap')"


HN_FILE="$CACHE_DIR/hn.txt"
HN=""

# handle case where HN_FILE does not exist yet
HN_FILE_TIME=2000
if [ -e "$HN_FILE" ] ; then
	HN_FILE_TIME=$(stat "$HN_FILE" -c %Y)
fi

HN_FILE_AGE=$(expr $(date +%s) - $HN_FILE_TIME)

# check if HN file has changed in the last 30 minutes, and if so just use it's
# contents
#
if [ $HN_FILE_AGE -gt 1800 ] ; then
	echo "INFO: HN file is out of date, regenerating... "

	# fetch and extract post titles
	POST_TITLES="$(query-webpage \
		--url 'https://news.ycombinator.com/' \
		--query '//a[contains(@class, "storylink")]' \
		--extract | head -n 5)"

	if [ "$POST_TITLES" = "" ] ; then
		# handle network outage, just use whatever was in the
		# HN file last.
		HN="$(cat "$HN_FILE")"
		echo "INFO: failed to retrieve HN posts"
	else
		# add an extra newline after every post title and wrap it to 40
		# columns. The sed command escapes any instances of the ' character
		# in the post title, which would otherwise break convert's argument
		# parsing.
		HN="$(echo "$POST_TITLES" | awk '{print ; print "";}' | fold -w 40 -s | sed "s/'/\\\'/g")"
		echo "$HN" > "$HN_FILE"
	fi
else
	echo "INFO: HN file is $HN_FILE_AGE seconds old, which is still current"
	HN="$(cat "$HN_FILE")"
fi

# generate calendar ; we drop the first line and replace it with the
# current date, as there is not a good way to highlight the current date.
echo "INFO: generating calendar... "

# generate ncal output, and put brackets around the current day
CURRENT_DOM="$(date +"%-d")"
CALENDAR="$(ncal -M -h -b | sed "s/ $CURRENT_DOM /[$CURRENT_DOM]/g")"
CALENDAR="$(vpad "$CALENDAR" 9)"

# hostname and IP address
echo "INFO: gathering host information... "
HOST_INFO="$(whoami)@$(hostname) ($(get-ip))"
HOST_INFO="$(vpad "$HOST_INFO" 3)"

# uptime
echo "INFO: gathering uptime... "
# these sed commands replace every ',  ' with a newline, then delete leading
# whitespace, this produces a nice multi-line left-justified output.
UPTIME="$(uptime | sed 's/,  /\n/g' | sed 's/^ //g')"
UPTIME="$(vpad "$UPTIME" 5)"

# get mpc status
# TODO: would be cool to have this fetch the album art and burn that in also
echo "INFO: fetching MPC status"
MPC_STATUS="$(mpc status | head -n 2)"
if [ "$(echo "$MPC_STATUS" | wc -l)" -lt 2 ] ; then
	# handle case where no music is playing with MPC
	MPC_STATUS="<not playing>"
fi
MPC_STATUS="$(vpad "$MPC_STATUS" 4)"

# generate columns
COL_LEFT="$CALENDAR\n$WEATHER\n$BLK"
COL_RIGHT="$HOST_INFO\n$UPTIME\n$MPC_STATUS\n$HN"


#### generate output ##########################################################

echo "INFO: generating convert command... "
# setup convert command
CONVERT_CMD="convert"
CONVERT_CMD="$CONVERT_CMD -font '$FONT' "
CONVERT_CMD="$CONVERT_CMD -pointsize $FONTSIZE"
CONVERT_CMD="$CONVERT_CMD -fill '$FILLCOLOR'"

# insert draw calls
CONVERT_CMD="$CONVERT_CMD $(draw 8 10 "$COL_LEFT")"
CONVERT_CMD="$CONVERT_CMD $(draw 65 10 "$COL_RIGHT")"

# setup input and output file
CONVERT_CMD="$CONVERT_CMD '$INPUT' '$OUTPUT'"

echo "INFO: generated command: $CONVERT_CMD"

# we can't just use a bare $CONVERT_CMD because of string quoting issues
echo "INFO: executing convert... "
sh -c "$CONVERT_CMD"

#### clean up #################################################################

if [ "$SET_WALLPAPER" = "YES" ] ; then
	echo "INFO: setting wallpaper... "
	feh --bg-fill "$OUTPUT"
fi

if [ "$OUTPUT_IS_TEMP" = "YES" ] ; then
	echo "INFO: cleaning up... "
	rm -f "$OUTPUT"
fi
