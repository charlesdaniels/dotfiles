#!/usr/bin/env python3

import argparse
import sys
import os
import pathlib
import json
import subprocess
import pprint
import re
import traceback
import shutil
import stat
import urllib.request
import getpass

class TaskError(Exception):
    pass

class Task:

    def __init__(this, provides, manifest):

        this.provides = provides
        this.manifest = manifest

        this.manifest.append("task.json")
        this.manifest.append("doc.rst")

        this.status = "not started"
        this.result = {}
        this.require_task = []
        this.run_script = []
        this.require_uname = None
        this.copy_file = []
        this.mark_executable = []
        this.require_git = []
        this.require_http = []
        this.require_github = []
        this.require_sudo = False
        this.require_any = []
        this.require_file = []
        this.overlay = []

        this.env = {}

        try:
            this.env["HOME"] = pathlib.Path.home()
        except AttributeError:
            # This version of pathlib predates Path.home()
            this.env["HOME"] = pathlib.Path(os.path.expanduser("~"))

        this.env["BIN_DIR"] = this.env["HOME"] / "bin"
        this.env["TASK_DIR"] = pathlib.Path.cwd()

    def do_overlay(this):
        if len(this.overlay) == 0:
            return

        results = {}

        for src, dest in this.overlay:

            # apply env formatting to destiantion
            dest = pathlib.Path(apply_env_formatting(this.env, dest))

            rn = "Overlay {} over {}".format(src, dest)
            results[rn] = "\n"

            # Calculate the parent of the source of the overlay. For unknown
            # reasons, sometimes TASK_DIR is not of type pathlib.Path.
            parent = pathlib.Path(this.env["TASK_DIR"]) / src

            # for each source element under the parent...
            for spath in pathlib.Path(parent).glob("./**/*"):
                try:
                    # calculate destination for this element and it's parent
                    dpath = pathlib.Path(os.path.relpath(str(spath),
                                                         str(parent)))
                    dpath = dest / dpath
                    dparent = dpath.parent

                    # If the source file is a directory, then we create a
                    # directory at the destination, and we're done with this
                    # element.
                    if os.path.isdir(str(spath)):
                        results[rn] += "create directory '{}'\n".format(dpath)
                        os.makedirs(str(dpath), exist_ok=True)
                        continue

                    # Ensure the destination's parent directory exists.
                    results[rn] += "create directory '{}'\n".format(dparent)
                    os.makedirs(str(dparent), exist_ok=True)

                    # Explicitly delete the destination element if it exists
                    # already.
                    if dpath.exists():
                        results[rn] += "remove '{}'\n".format(str(dpath))
                        if os.path.isfile(str(dpath)):
                            os.remove(str(dpath))
                        else:
                            shutil.rmtree(str(dpath))

                    # perform a copy operation
                    results[rn] += "copy '{}' to {}'\n".format(spath, dpath)
                    shutil.copy(str(spath), str(dpath))

                except Exception as e:
                    results[rn] += str(e) + "\n"
                    this.status = "failed"

        this.result["overlay"] = results

    def do_copy_file(this):
        if len(this.copy_file) == 0:
            return

        os.chdir(str(this.env["TASK_DIR"]))

        results = {}
        for cp in this.copy_file:
            src = pathlib.Path(apply_env_formatting(this.env, cp[0]))
            dest = pathlib.Path(apply_env_formatting(this.env, cp[1]))
            rn = "Copy file '{}' to '{}'".format(src, dest)
            try:
                # explicitly delete the destination
                if dest.exists():
                    if os.path.isdir(str(dest)):
                        shutil.rmtree(str(dest))
                    else:
                        dest.unlink()

                # perform the copy
                shutil.copyfile(str(src), str(dest))
                results[rn] = "Copy finished ok."
            except Exception as e:
                this.status = "failed"
                results[rn] = str(e)

        this.result["copy-file"] = results

    def do_require_github(this):
        for g in this.require_github:
            url, clonedir, branch = g
            fullurl = "https://github.com/{}.git".format(url)
            this.require_git.append([fullurl, clonedir, branch])

    def do_require_file(this):
        if len(this.require_file) == 0:
            return

        results = {}
        for f in this.require_file:
            f = pathlib.Path(f)
            rn = "File '{}' must exist".format(f)
            if f.exists():
                results[rn] = "File exists."
            else:
                results[rn] = "File does not exist."
                this.status = "failed"

        this.result["require-file"] = results

    def do_require_http(this):
        if len(this.require_http) == 0:
            return

        results = {}
        for h in this.require_http:
            url, dest = h
            dest = dest.format(this.env)
            rn = "Download file '{}' to '{}'".format(url, dest)
            try:
                urllib.request.urlretrieve(url, dest)
                results[rn] = "Download ok."
            except Exception as e:
                this.status = "failed"
                results[rn] = str(e)

        this.result["require-http"] = results

    def do_require_git(this):
        if len(this.require_git) == 0:
            return

        results = {}
        for g in this.require_git:
            os.chdir(str(this.env["TASK_DIR"]))
            url, clonedir, branch = g

            clonedir = pathlib.Path(clonedir)

            rn = "Clone git repository '{}' on branch '{}' to '{}'" \
                    .format(url, branch, clonedir)
            results[rn] = "\n"

            if not clonedir.exists():
                # Assume we have not cloned this repository before
                results[rn] = "$ git clone {} {}\n".format(url, clonedir)
                try:
                    result = subprocess.check_output(
                            ["git", "clone", url, str(clonedir)],
                            stderr=subprocess.PIPE)
                    result = result.decode("utf-8")
                    result = result.strip()
                    results[rn] += result + "\n"
                except Exception as e:
                    results[rn] += str(e)
                    this.status = "failed"
                    continue

            # At this point, we have either cloned the repo, or we assume it
            # was already cloned previously since the dest already exists.

            os.chdir(str(clonedir))

            try:
                # Checkout the specified branch.
                results[rn] += "$ git checkout {}\n".format(branch)
                result = subprocess.check_output(
                        ["git", "checkout", branch],
                        stderr=subprocess.PIPE)
                result = result.decode("utf-8")
                result = result.strip()
                results[rn] += result + "\n"

                # Reset it to HEAD, in case we have modified it since the last
                # run.
                results[rn] += "$ git reset --hard HEAD\n"
                result = subprocess.check_output(
                        ["git", "reset", "--hard", "HEAD"],
                        stderr=subprocess.PIPE)
                result = result.decode("utf-8")
                result = result.strip()
                results[rn] += result + "\n"


            except Exception as e:
                results[rn] += str(e)
                this.status = "failed"
                continue

            try:

                # Pull the origin down. this is in a separate try/except block
                # since if it fails, it indicates a network error, which should
                # be non-fatal if possible.

                results[rn] += "$ git pull origin {}\n".format(branch)
                result = subprocess.check_output(
                        ["git", "pull", "origin", branch],
                        stderr=subprocess.PIPE)
                result = result.decode("utf-8")
                result = result.strip()
                results[rn] += result + "\n"

            except Exception as e:
                results[rn] += "\nFailed to pull origin. Failure is non"
                results[rn] += "-fatal to task completion.\n"

        # Generate a gitignore file so that if we are already part of a git
        # repo the user does not accidentally check the one we just cloned in.
        gitignore = this.env["TASK_DIR"] / ".gitignore"
        if not gitignore.exists():
            with open(str(gitignore), "w") as f:
                for g in this.require_git:
                    url, clonedir, branch = g
                    f.write(clonedir)
                    f.write("\n")


        this.result["require-git"] = results

    def do_mark_executable(this):
        if len(this.mark_executable) == 0:
            return

        results = {}
        for mx in this.mark_executable:
            mx = pathlib.Path(apply_env_formatting(this.env, mx))
            rn = "Mark file '{}' executable".format(mx)
            try:
                st = mx.stat()
                os.chmod(str(mx), st.st_mode | stat.S_IXUSR | stat.S_IXGRP |
                        stat.S_IXOTH)
                results[rn] = "Chmod finished ok."
            except Exception as e:
                this.status = "failed"
                results[rn] = str(e)

        this.result["mark-executable"] = results

    def do_run_script(this):
        if len(this.run_script) == 0:
            return

        os.chdir(str(this.env["TASK_DIR"]))

        # copy existing environment into the one we will use with subprocess
        scriptenv = {}
        for key in os.environ:
            scriptenv[key] = os.environ[key]

        for k in this.env:
            scriptenv["TASKUTIL_"+k] = str(this.env[k])

        results = {}
        for cmd in this.run_script:
            cmd = [apply_env_formatting(this.env, x) for x in cmd]
            try:
                result = subprocess.check_output(cmd,
                        env=scriptenv, stdin=subprocess.DEVNULL,
                        stderr=subprocess.PIPE)
                result = result.decode("utf-8")
                result = result.strip()
                results[str(cmd)] = result
            except subprocess.CalledProcessError as e:
                results[str(cmd)] = str(e)
                results[str(cmd)] += "\n- - - stdout - - -\n"
                results[str(cmd)] += e.output.decode("utf-8")
                results[str(cmd)] += "\n- - - stderr - - -\n"
                results[str(cmd)] += e.stderr.decode("utf-8")
                this.status = "failed"

            except Exception as e:
                results[str(cmd)] = str(e)
                this.status = "failed"

        this.result["run-script"] = results

    def do_require_uname(this):
        if this.require_uname is None:
            return

        uname_regex = re.compile(this.require_uname)
        uname = subprocess.check_output(["uname"]).decode("utf-8").strip()
        if not uname_regex.match(uname):
            this.result["require-uname"] = \
                    "Uname '{}' did not match regext {}'".format(
                        uname, this.require_uname)
            this.status = "failed"
        else:
            this.result["require-uname"] = \
                    "Uname '{}' matched regex '{}'".format(
                        uname, this.require_uname)

    def generate_graphviz(this, seen_nodes = [], seen_edges = []):
        s = ""
        if this.provides not in seen_nodes:
            if this.provides != "__master__":
                if this.require_sudo:
                    s = '\t"{}" [color=red];\n'.format(this.provides)
                elif this.predict_sudo():
                    s = '\t"{}" [color=orange];\n'.format(this.provides)
                else:
                    s = '\t"{}";\n'.format(this.provides)
            seen_nodes.append(this.provides)

        for t in this.require_task:
            s += t.generate_graphviz(seen_nodes, seen_edges)
        for t in this.require_task:
            edge = (this.provides, t.provides)
            if edge not in seen_edges:
                if this.provides != "__master__":
                    s += '\t"{}" -> "{}";\n'.format(this.provides, t.provides)
                seen_edges.append(edge)

        for g in this.require_any:
            for t in g:
                s += t.generate_graphviz(seen_nodes, seen_edges)
            for t in g:
                edge = (this.provides, t.provides)
                if edge not in seen_edges:
                    s += '\t"{}" -> "{}" [style=dashed];\n' \
                            .format(this.provides, t.provides)
                    seen_edges.append(edge)

        return s

    def hydrate(this, tasks):
        for i in range(len(this.require_task)):
            if type(this.require_task[i]) is str:
                if this.require_task[i] not in tasks:
                    sys.stderr.write("FATAL: unknown task '{}' "
                            .format(this.require_task[i]))
                    sys.stderr.write("while hydrating task '{}'.\n"
                            .format(this.provides))
                    raise TaskError()
                this.require_task[i] = tasks[this.require_task[i]]

            try:
                this.require_task[i].hydrate(tasks)
            except RecursionError:
                sys.stderr.write("FATAL: loop detected while processing task")
                sys.stderr.write(" '{}'; tasks do not from a DAG.\n"
                                 .format(this.provides))
                raise TaskError()

        for i in range(len(this.require_any)):
            for j in range(len(this.require_any[i])):
                taskname = this.require_any[i][j]
                if type(taskname) is not str:
                    # dont hydrate the same task more than once
                    continue
                if taskname not in tasks:
                    sys.stderr.write("FATAL: unknown task '{}'"
                            .format(taskname))
                    sys.stderr.write("while hydrating task '{}'.\n"
                            .format(this.provides))
                    raise TaskError()
                this.require_any[i][j] = tasks[taskname]
                this.require_any[i][j].hydrate(tasks)


    def predict_sudo(this):
        if this.require_sudo:
            return True

        for t in this.require_task:
            if t.predict_sudo():
                return True

        return False


    def execute(this, sudo_pw=None):

        # ensure we have the sudo password if we need it
        if this.predict_sudo():
            if (sudo_pw is None) and (not sys.stdin.isatty()):
                this.status = "failed"
                this.result["require-sudo"] = "Task requires sudo and " + \
                    "no sudo password was provided"
            elif sudo_pw is None:
                sudo_pw = getpass.getpass("Sudo password is required: ")

            this.env["SUDO_PASSWORD"] = sudo_pw

        # ensure all dependencies are satisfied
        for task in this.require_task:
            if task.status == "not started":
                task.execute(sudo_pw=sudo_pw)

            if task.status == "failed":
                this.status = "failed"
                if "require-task" not in this.result:
                    this.result["require-task"] = {}
                this.result["require-task"][task.provides] = \
                        "Task '{}' reported itself to be in failure state" \
                        .format(task.provides)

        # ensure any "any" groups are satisfied
        for group in this.require_any:
            if "require-any" not in this.result:
                this.result["require-any"] = {}
            group_ok = False
            group_name = str([x.provides for x in group])
            for task in group:
                if task.status == "not started":
                    task.execute()

                if task.status == "complete":
                    group_ok = True
                    break

            if not group_ok:
                this.status = "failed"
                this.result["require-any"][group_name] = "No tasks in " + \
                    "group completed successfully."
            else:
                this.result["require-any"][group_name] = "One or more tasks" +\
                    " in group completed successfully."

        if this.status != "failed":
            os.chdir(str(this.env["TASK_DIR"]))
            this.do_require_uname()
            this.do_require_file()
            this.do_require_github()
            this.do_require_git()
            this.do_require_http()
            this.do_overlay()
            this.do_copy_file()
            this.do_mark_executable()
            this.do_run_script()


        if this.status != "failed":
            this.status = "complete"

    def get_result_summary(this, seen=[]):
        s = ""
        if this.provides not in seen:
            seen.append(this.provides)

            # task name
            s = "{}: {}\n".format(this.provides, this.status)

            for k in this.result:
                s += "\t{}: ".format(k)

                # case where result is a string
                if type(this.result[k]) is str:
                    s += '\n\t\t'.join(this.result[k].split('\n'))
                    s += "\n"

                # case where result is a list
                elif type(this.result[k]) is list:
                    s += "\n"
                    for li in this.result[k]:
                        s += "\t\t{}\n".format(li)

                # case where result is a nested table
                elif type(this.result[k]) is dict:
                    s += "\n"

                    # iterate over nested fields
                    for ik in this.result[k]:

                        # string fields
                        if type(this.result[k]) is str:
                            s += '\n\t\t\t'.join(this.result[k].split('\n'))
                            s += "\n"

                        # list fields
                        elif type(this.result[k]) is list:
                            s += "\n"
                            for li in this.result[k]:
                                s += "\t\t\t{}\n".format(li)

                        # unknown fields
                        else:
                            s += "\t\t{}: ".format(ik)
                            s += '\n\t\t\t'.join(
                                    str(this.result[k][ik]).split('\n'))
                            s += "\n"

                # case where field type is not known
                else:
                    s += '\n\t\t'.join(str(this.result[k]).split('\n'))
                    s += "\n"

            s += "\n"

        # descend into required tasks
        for t in this.require_task:
            if t in seen:
                continue
            s += t.get_result_summary(seen=seen)

        # descend into require-any tasks
        for g in this.require_any:
            for t in g:
                if t in seen:
                    continue
                s += t.get_result_summary(seen=seen)

        return s

    def clean(this):
        dirstack = []
        for p in pathlib.Path(this.env["TASK_DIR"]).glob("./**/*"):

            if this.provides == "__master__":
                # should never be directly cleaning files under __master__
                # because it points to the taskutil install dir.
                break

            delete = True
            for mg in this.manifest:
                mg = pathlib.Path(mg)
                mg = this.env["TASK_DIR"] / mg

                # pathlib.glob does not support globbing on absolute paths,
                # so we convert to a relative path
                mg = os.path.relpath(str(mg), str(os.getcwd()))
                mg = pathlib.Path(mg)

                for m in pathlib.Path().glob(str(mg)):
                    m = pathlib.Path(os.path.realpath(str(m)))
                    p = pathlib.Path(os.path.realpath(str(p)))
                    if os.path.normpath(str(p)) == os.path.normpath(str(m)):
                        delete = False

            if delete:
                sys.stderr.write("removing: {}\n".format(p))
                try:
                    if p.is_dir():
                        dirstack.append(p)
                    elif p.is_symlink():
                        p.unlink()
                    else:
                        p.unlink()
                except Exception as e:
                    print_warning("Failed to delete '{}': {}".format(p, e))


        # we try to delete everything many times in case there are nested
        # sub-directories
        for i in range(len(dirstack)):
            for p in dirstack:
                    try:
                        p.rmdir()
                        pass
                    except Exception as e:
                        pass

        for p in dirstack:
            if not p.exists():
                continue

            try:
                p.rmdir()
            except Exception as e:
                print_warning("Could not delete '{}': {}".format(p, e))

        for r in this.require_task:
            r.clean()

    def index_failed(this):
        failed = set()

        if this.status == "failed":
            failed.add(this.provides)

        for t in this.require_task:
            for f in t.index_failed():
                failed.add(f)
        for g in this.require_any:
            for t in g:
                for f in t.index_failed():
                    failed.add(f)
        return failed

    def __str__(this):
        return "{}: {}".format(this.provides, this.status)

def apply_env_formatting(env, s):
    s = str(s)
    for key in env:
        env[key] = str(env[key])
        s = s.format(**env)
        return s

def print_warning(msg):
    sys.stderr.write("WARNING: {}\n".format(msg))
    sys.stderr.flush()

def index_tasks(taskstore):
    pathlist = pathlib.Path(taskstore).glob("*/task.json")
    tasks = {}
    for p in pathlist:
        with open(str(p), 'r') as f:
            j = None
            try:
                j = json.load(f)
            except Exception  as e:
                sys.stderr.write("FATAL: failed to load JSON file '{}': {}\n"
                                 .format(str(p), str(e)))
                exit(1)

            name = j["provides"]
            if 'provides' not in j:
                print_warning("taskfile is missing 'provides' field: {}"
                              .format(p))
                continue
            if 'manifest' not in j:
                print_warning("taskfile is missing 'manifest' field: {}"
                              .format(p))
                continue
            if name in tasks:
                print_warning("duplicate provider for '{}' in: {}"
                              .format(name, p))
                continue

            task = Task(name, j["manifest"])

            task.env["TASK_DIR"] = p.parent


            if 'require-task' in j:
                task.require_task = j["require-task"]

            if 'require-any' in j:
                task.require_any = j["require-any"]

            if 'run-script' in j:
                task.run_script = j["run-script"]

            if 'require-uname' in j:
                task.require_uname = j["require-uname"]

            if 'copy-file' in j:
                task.copy_file = j["copy-file"]

            if 'mark-executable' in j:
                task.mark_executable = j["mark-executable"]

            if 'require-git' in j:
                task.require_git = j["require-git"]

            if 'require-github' in j:
                task.require_github = j["require-github"]

            if 'require-http' in j:
                task.require_http = j["require-http"]

            if 'require-sudo' in j:
                task.require_sudo = j["require-sudo"]

            if 'require-file' in j:
                task.require_file = j["require-file"]

            if 'overlay' in j:
                task.overlay = j["overlay"]

            tasks[name] = task

    return tasks

def generate_summary(tasks):
    summary = {}
    for name in tasks:
        summary[name] = tasks[name].result
        summary[name]["status"] = tasks[name].status
    return summary


def format_summary_list(l, indent):
    s = ""
    for elem in l:
        if type(elem) is list:
            s += format_summary_list(elem, indent + 1)
        elif type(elem) is dict:
            s += format_summary_dict(elem, indent + 1)
        else:
            s += format_summary_other(elem, indent + 1)

def format_summary_other(o, indent):
    s = ""
    s = "\t" * indent
    s += ("\n" + "\t" * indent).join(str(o).split("\n"))
    s += "\n"
    return s

def format_summary_dict(d, indent=0):
    s = ""
    for key in d:
        s += "\t" * indent + key + ":\n"
        if type(d[key]) is list:
            s += format_summary_list(d[key], indent + 1)
        elif type(d[key]) is dict:
            s += format_summary_dict(d[key], indent + 1)
        else:
            s += format_summary_other(d[key], indent + 1)
    return s

def format_summary(summary):
    s = ""
    for key in summary:
        elem = summary[key]
        if elem["status"] == "not started":
            continue
        elif elem["status"] == "complete":
            s += "{}: complete\n".format(key)
        else:
            s += "{}:\n".format(key)
            s += format_summary_dict(summary[key], 1)

    return s


def main():
    parser = argparse.ArgumentParser()

    action_group = parser.add_mutually_exclusive_group()

    action_group.add_argument("--run", "-r", nargs="+", default=None,
            help="List one or more tasks to execute")

    action_group.add_argument("--list", "-l",
            default=False, action="store_true")

    action_group.add_argument("--visualize", "-s", nargs="*",
            default=None)

    action_group.add_argument("--clean", "-c", nargs="*",
            default=None)

    sudo_group = parser.add_mutually_exclusive_group()

    sudo_group.add_argument("--sudo_password", "-p", default=None,
                            help="Specify password for sudo as an argument")

    sudo_group.add_argument("--sudo_file", "-f", default=None,
                            help="Specify a file which contains the " +
                            "password for sudo.")

    parser.add_argument("--write_summary", "-w", default=None,
                        help="Specify a JSON file to write summary to.")

    parser.add_argument("--print_summary", "-n", default=False,
                        action="store_true", help="Display summary to " +
                        "standard out.")

    args = parser.parse_args()

    sudo_pw = None
    if args.sudo_password is not None:
        sudo_pw = args.sudo_password
    elif args.sudo_file is not None:
        with open(args.sudo_file, 'r') as f:
            sudo_pw = f.read()

    base_dir = pathlib.Path(os.path.dirname(os.path.realpath(str(__file__))))
    tasks_dir = base_dir / "tasks"

    tasks = index_tasks(tasks_dir)

    if args.list:
        sys.stdout.write("\n".join(tasks.keys()))
        sys.stdout.write("\n")
        sys.stdout.flush()
        exit(0)

    if args.visualize is not None:
        master = Task("__master__", [])

        if len(args.visualize) == 0:
            master.require_task = list(tasks.keys())
        else:
            master.require_task = args.visualize

        master.hydrate(tasks)

        sys.stdout.write("digraph G {\n")
        sys.stdout.write("\trankdir=LR;\n")
        sys.stdout.write(master.generate_graphviz())
        sys.stdout.write("}\n")

    if args.clean is not None:
        master = Task("__master__", [])

        if len(args.clean) == 0:
            master.require_task = list(tasks.keys())
        else:
            master.require_task = args.clean

        master.hydrate(tasks)
        master.clean()

    if args.run is not None:
        master = Task("__master__", [])
        master.require_task = args.run

        master.hydrate(tasks)

        master.execute(sudo_pw=sudo_pw)

        summary = generate_summary(tasks)

        if args.write_summary is not None:
            with open(args.write_summary, "w") as f:
                json.dump(summary, f, indent=4)

        if args.print_summary:
            sys.stdout.write(format_summary(summary))

        for failed in master.index_failed():
            print_warning("Task {} failed.".format(failed))

        num_failed = len(master.index_failed())
        if num_failed > 0:
            print_warning("{} tasks failed".format(num_failed))
            exit(num_failed)


if __name__ == "__main__":
    try:
        main()
    except TaskError:
        sys.stderr.write("FATAL: a task exception was encountered.\n")
        exit(1)
