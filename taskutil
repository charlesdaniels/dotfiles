#!/usr/bin/env python3

import argparse
import sys
import os
import pathlib
import json
import subprocess
import pprint
import re
import traceback
import shutil
import stat
import urllib.request
import getpass

class TaskError(Exception):
    pass

class Task:

    def __init__(this, provides, manifest):

        this.provides = provides
        this.manifest = manifest

        this.manifest.append("task.json")

        this.status = "not started"
        this.result = {}
        this.require_task = []
        this.run_script = []
        this.require_uname = None
        this.copy_file = []
        this.mark_executable = []
        this.require_git = []
        this.require_http = []
        this.require_github = []
        this.require_sudo = False
        this.require_any = []
        this.require_file = []
        this.overlay = []

        this.env = {}
        this.env["HOME"] = os.path.expanduser("~")
        this.env["BIN_DIR"] = os.path.join(this.env["HOME"], "bin")
        this.env["TASK_DIR"] = os.getcwd()

    def do_overlay(this):
        if len(this.overlay) == 0:
            return

        results = {}

        for src, dest in this.overlay:
            dest = dest.format(**this.env)
            rn = "Overlay {} over {}".format(src, dest)
            results[rn] = "\n"
            parent = os.path.join(this.env["TASK_DIR"], src)
            for spath in pathlib.Path(parent).glob("./**/*"):
                try:
                    dpath = os.path.relpath(spath, parent)
                    dpath = os.path.join(dest, dpath)
                    dparent = os.path.dirname(dpath)

                    if os.path.isdir(spath):
                        results[rn] += "create directory '{}'\n".format(dpath)
                        os.makedirs(dpath, exist_ok=True)
                        continue

                    # ensure the destination's parent directory exists
                    results[rn] += "create directory '{}'\n".format(dparent)
                    os.makedirs(dparent, exist_ok=True)

                    # explicitly delete the dest if it exists
                    if os.path.exists(dpath):
                        results[rn] += "remove '{}'\n".format(dpath)
                        if os.path.isfile(dpath):
                            os.remove(dpath)
                        else:
                            shutil.rmtree(dpath)

                    # perform a copy operation
                    results[rn] += "copy '{}' to {}'\n".format(spath, dpath)
                    shutil.copy(spath, dpath)
                except Exception as e:
                    results[rn] += str(e) + "\n"
                    this.status = "failed"

        this.result["overlay"] = results

    def do_copy_file(this):
        if len(this.copy_file) == 0:
            return

        os.chdir(this.env["TASK_DIR"])

        results = {}
        for cp in this.copy_file:
            src = cp[0].format(**this.env)
            dest = cp[1].format(**this.env)
            rn = "Copy file '{}' to '{}'".format(src, dest)
            try:
                # explicitly delete the destination
                if os.path.exists(dest):
                    if os.path.isdir(dest):
                        shutil.rmtree(dest)
                    else:
                        os.remove(dest)

                # perform the copy
                shutil.copyfile(src, dest)
                results[rn] = "Copy finished ok."
            except Exception as e:
                this.status = "failed"
                results[rn] = str(e)

        this.result["copy-file"] = results

    def do_require_github(this):
        for g in this.require_github:
            url, clonedir, branch = g
            fullurl = "https://github.com/{}.git".format(url)
            this.require_git = [[fullurl, clonedir, branch], *this.require_git]

    def do_require_file(this):
        if len(this.require_file) == 0:
            return

        results = {}
        for f in this.require_file:
            rn = "File '{}' must exist".format(f)
            if os.path.exists(f):
                results[rn] = "File exists."
            else:
                results[rn] = "File does not exist."
                this.status = "failed"

        this.result["require-file"] = results

    def do_require_http(this):
        if len(this.require_http) == 0:
            return

        results = {}
        for h in this.require_http:
            url, dest = h
            dest = dest.format(this.env)
            rn = "Download file '{}' to '{}'".format(url, dest)
            try:
                urllib.request.urlretrieve(url, dest)
                results[rn] = "Download ok."
            except Exception as e:
                this.status = "failed"
                results[rn] = str(e)

        this.result["require-http"] = results

    def do_require_git(this):
        if len(this.require_git) == 0:
            return

        results = {}
        for g in this.require_git:
            os.chdir(this.env["TASK_DIR"])
            url, clonedir, branch = g
            rn = "Clone git repository '{}' on branch '{}' to '{}'" \
                    .format(url, branch, clonedir)
            results[rn] = "\n"
            if not os.path.exists(clonedir):
                results[rn] = "$ git clone {} {}\n".format(url, clonedir)
                try:
                    result = subprocess.check_output(
                            ["git", "clone", url, clonedir],
                            stderr=subprocess.PIPE)
                    result = result.decode("utf-8")
                    result = result.strip()
                    results[rn] += result + "\n"
                except Exception as e:
                    results[rn] += str(e)
                    this.status = "failed"
                    continue

            os.chdir(clonedir)

            try:
                results[rn] += "$ git checkout {}\n".format(branch)
                result = subprocess.check_output(
                        ["git", "checkout", branch],
                        stderr=subprocess.PIPE)
                result = result.decode("utf-8")
                result = result.strip()
                results[rn] += result + "\n"

                results[rn] += "$ git reset --hard HEAD\n"
                result = subprocess.check_output(
                        ["git", "reset", "--hard", "HEAD"],
                        stderr=subprocess.PIPE)
                result = result.decode("utf-8")
                result = result.strip()
                results[rn] += result + "\n"


            except Exception as e:
                results[rn] += str(e)
                this.status = "failed"
                continue

            try:

                results[rn] += "$ git pull origin {}\n".format(branch)
                result = subprocess.check_output(
                        ["git", "pull", "origin", branch],
                        stderr=subprocess.PIPE)
                result = result.decode("utf-8")
                result = result.strip()
                results[rn] += result + "\n"

            except Exception as e:
                results[rn] += "\nFailed to pull origin. Failure is non"
                results[rn] += "-fatal to task completion.\n"

        gitignore = os.path.join(this.env["TASK_DIR"], ".gitignore")
        if not os.path.exists(gitignore):
            with open(gitignore, "w") as f:
                for g in this.require_git:
                    url, clonedir, branch = g
                    f.write(clonedir)
                    f.write("\n")


        this.result["require-git"] = results

    def do_mark_executable(this):
        if len(this.mark_executable) == 0:
            return

        results = {}
        for mx in this.mark_executable:
            mx = mx.format(**this.env)
            rn = "Mark file '{}' executable".format(mx)
            try:
                st = os.stat(mx)
                os.chmod(mx, st.st_mode | stat.S_IXUSR | stat.S_IXGRP |
                        stat.S_IXOTH)
                results[rn] = "Chmod finished ok."
            except Exception as e:
                this.status = "failed"
                results[rn] = str(e)

        this.result["mark-executable"] = results

    def do_run_script(this):
        if len(this.run_script) == 0:
            return

        os.chdir(this.env["TASK_DIR"])

        scriptenv = { ** os.environ }
        for k in this.env:
            scriptenv["TASKUTIL_"+k] = this.env[k]

        results = {}
        for cmd in this.run_script:
            try:
                result = subprocess.check_output(cmd,
                        env=scriptenv, stdin=subprocess.DEVNULL,
                        stderr=subprocess.PIPE)
                result = result.decode("utf-8")
                result = result.strip()
                results[str(cmd)] = result
            except subprocess.CalledProcessError as e:
                results[str(cmd)] = str(e)
                results[str(cmd)] += "\n- - - stdout - - -\n"
                results[str(cmd)] += e.output.decode("utf-8")
                results[str(cmd)] += "\n- - - stderr - - -\n"
                results[str(cmd)] += e.stderr.decode("utf-8")
                this.status = "failed"

            except Exception as e:
                results[str(cmd)] = str(e)
                this.status = "failed"

        this.result["run-script"] = results

    def do_require_uname(this):
        if this.require_uname is None:
            return

        uname_regex = re.compile(this.require_uname)
        uname = subprocess.check_output(["uname"]).decode("utf-8").strip()
        if not uname_regex.match(uname):
            this.result["require-uname"] = \
                    "Uname '{}' did not match regext {}'".format(
                        uname, this.require_uname)
            this.status = "failed"
        else:
            this.result["require-uname"] = \
                    "Uname '{}' matched regex '{}'".format(
                        uname, this.require_uname)

    def generate_graphviz(this, seen_nodes = [], seen_edges = []):
        s = ""
        if this.provides not in seen_nodes:
            if this.provides != "__master__":
                s = '\t"{}";\n'.format(this.provides)
            seen_nodes.append(this.provides)

        for t in this.require_task:
            s += t.generate_graphviz(seen_nodes, seen_edges)
        for t in this.require_task:
            edge = (this.provides, t.provides)
            if edge not in seen_edges:
                if this.provides != "__master__":
                    s += '\t"{}" -> "{}";\n'.format(this.provides, t.provides)
                seen_edges.append(edge)

        for g in this.require_any:
            for t in g:
                s += t.generate_graphviz(seen_nodes, seen_edges)
            for t in g:
                edge = (this.provides, t.provides)
                if edge not in seen_edges:
                    s += '\t"{}" -> "{}" [style=dashed];\n' \
                            .format(this.provides, t.provides)
                    seen_edges.append(edge)

        return s

    def hydrate(this, tasks):
        for i in range(len(this.require_task)):
            if type(this.require_task[i]) is str:
                if this.require_task[i] not in tasks:
                    sys.stderr.write("FATAL: unknown task '{}'\n"
                            .format(this.require_task[i]))
                    raise TaskError()
                this.require_task[i] = tasks[this.require_task[i]]
            this.require_task[i].hydrate(tasks)

        for i in range(len(this.require_any)):
            for j in range(len(this.require_any[i])):
                taskname = this.require_any[i][j]
                if type(taskname) is not str:
                    # dont hydrate the same task more than once
                    continue
                if taskname not in tasks:
                    sys.stderr.write("FATAL: unknown task '{}'\n"
                            .format(taskname))
                    raise TaskError()
                this.require_any[i][j] = tasks[taskname]
                this.require_any[i][j].hydrate(tasks)


    def predict_sudo(this):
        if this.require_sudo:
            return True

        for t in this.require_task:
            if t.predict_sudo():
                return True

        return False


    def execute(this, sudo_pw=None):

        # ensure we have the sudo password if we need it
        if this.predict_sudo():
            if (sudo_pw is None) and (not sys.stdin.isatty()):
                this.status = "failed"
                this.result["require-sudo"] = "Task requires sudo and " + \
                    "no sudo password was provided"
            elif sudo_pw is None:
                sudo_pw = getpass.getpass("Sudo password is required: ")

            this.env["SUDO_PASSWORD"] = sudo_pw

        # ensure all dependencies are satisfied
        for task in this.require_task:
            if task.status == "not started":
                task.execute(sudo_pw=sudo_pw)

            if task.status == "failed":
                this.status = "failed"
                if "require-task" not in this.result:
                    this.result["require-task"] = {}
                this.result["require-task"][task.provides] = \
                        "Task '{}' reported itself to be in failure state" \
                        .format(task.provides)

        # ensure any "any" groups are satisfied
        for group in this.require_any:
            if "require-any" not in this.result:
                this.result["require-any"] = {}
            group_ok = False
            group_name = str([x.provides for x in group])
            for task in group:
                if task.status == "not started":
                    task.execute()

                if task.status == "complete":
                    group_ok = True
                    break

            if not group_ok:
                this.status = "failed"
                this.result["require-any"][group_name] = "No tasks in " + \
                    "group completed successfully."
            else:
                this.result["require-any"][group_name] = "One or more tasks" +\
                    " in group completed successfully."

        if this.status != "failed":
            os.chdir(this.env["TASK_DIR"])
            this.do_require_uname()
            this.do_require_file()
            this.do_require_github()
            this.do_require_git()
            this.do_require_http()
            this.do_overlay()
            this.do_copy_file()
            this.do_mark_executable()
            this.do_run_script()


        if this.status != "failed":
            this.status = "complete"

    def get_result_summary(this, seen=[]):
        s = ""
        if this.provides not in seen:
            seen.append(this.provides)

            # task name
            s = "{}: {}\n".format(this.provides, this.status)

            for k in this.result:
                s += "\t{}: ".format(k)

                # case where result is a string
                if type(this.result[k]) is str:
                    s += '\n\t\t'.join(this.result[k].split('\n'))
                    s += "\n"

                # case where result is a list
                elif type(this.result[k]) is list:
                    s += "\n"
                    for li in this.result[k]:
                        s += "\t\t{}\n".format(li)

                # case where result is a nested table
                elif type(this.result[k]) is dict:
                    s += "\n"

                    # iterate over nested fields
                    for ik in this.result[k]:

                        # string fields
                        if type(this.result[k]) is str:
                            s += '\n\t\t\t'.join(this.result[k].split('\n'))
                            s += "\n"

                        # list fields
                        elif type(this.result[k]) is list:
                            s += "\n"
                            for li in this.result[k]:
                                s += "\t\t\t{}\n".format(li)

                        # unknown fields
                        else:
                            s += "\t\t{}: ".format(ik)
                            s += '\n\t\t\t'.join(
                                    str(this.result[k][ik]).split('\n'))
                            s += "\n"

                # case where field type is not known
                else:
                    s += '\n\t\t'.join(str(this.result[k]).split('\n'))
                    s += "\n"

            s += "\n"

        # descend into required tasks
        for t in this.require_task:
            if t in seen:
                continue
            s += t.get_result_summary(seen=seen)

        # descend into require-any tasks
        for g in this.require_any:
            for t in g:
                if t in seen:
                    continue
                s += t.get_result_summary(seen=seen)

        return s

    def clean(this):
        dirstack = []
        for p in pathlib.Path(this.env["TASK_DIR"]).glob("./**/*"):

            if this.provides == "__master__":
                # should never be directly cleaning files under __master__
                # because it points to the taskutil install dir.
                break

            delete = True
            for mg in this.manifest:
                mg = os.path.join(this.env["TASK_DIR"], mg)

                # pathlib.glob does not support globbing on absolute paths,
                # so we convert to a relative path
                mg = os.path.relpath(mg, os.getcwd())

                for m in pathlib.Path().glob(mg):
                    m = os.path.realpath(m)
                    p = os.path.realpath(p)
                    if os.path.normpath(p) == os.path.normpath(m):
                        sys.stderr.write("protected: {}\n".format(m))
                        delete = False

            if delete:
                if os.path.isfile(p):
                    sys.stderr.write("removing: {}\n".format(p))
                    os.remove(p)
                else:
                    dirstack.append(p)

        # we try to delete everything many times in case there are nested
        # sub-directories
        for i in range(len(dirstack)):
            for p in dirstack:
                    try:
                        os.rmdir(p)
                        pass
                    except Exception as e:
                        pass

        for p in dirstack:
            if not os.path.exists(p):
                continue

            try:
                os.rmdir(p)
            except Exception as e:
                print_warning("Could not delete '{}': {}".format(p, e))

        for r in this.require_task:
            r.clean()

    def __str__(this):
        return "{}: {}".format(this.provides, this.status)


def print_warning(msg):
    sys.stderr.write("WARNING: {}\n".format(msg))
    sys.stderr.flush()

def index_tasks(taskstore):
    pathlist = pathlib.Path(taskstore).glob("*/task.json")
    tasks = {}
    for p in pathlist:
        with open(str(p), 'r') as f:
            j = json.load(f)
            name = j["provides"]
            if 'provides' not in j:
                print_warning("taskfile is missing 'provides' field: {}"
                              .format(p))
                continue
            if 'manifest' not in j:
                print_warning("taskfile is missing 'manifest' field: {}"
                              .format(p))
                continue
            if name in tasks:
                print_warning("duplicate provider for '{}' in: {}"
                              .format(name, p))
                continue

            task = Task(name, j["manifest"])

            task.env["TASK_DIR"] = os.path.dirname(p)

            if 'require-task' in j:
                task.require_task = j["require-task"]

            if 'require-any' in j:
                task.require_any = j["require-any"]

            if 'run-script' in j:
                task.run_script = j["run-script"]

            if 'require-uname' in j:
                task.require_uname = j["require-uname"]

            if 'copy-file' in j:
                task.copy_file = j["copy-file"]

            if 'mark-executable' in j:
                task.mark_executable = j["mark-executable"]

            if 'require-git' in j:
                task.require_git = j["require-git"]

            if 'require-github' in j:
                task.require_github = j["require-github"]

            if 'require-http' in j:
                task.require_http = j["require-http"]

            if 'require-sudo' in j:
                task.require_sudo = j["require-sudo"]

            if 'require-file' in j:
                task.require_file = j["require-file"]

            if 'overlay' in j:
                task.overlay = j["overlay"]

            tasks[name] = task

    return tasks

def generate_summary(tasks):
    summary = {}
    for name in tasks:
        summary[name] = tasks[name].result
        summary[name]["status"] = tasks[name].status
    return summary


def format_summary_list(l, indent):
    s = ""
    for elem in l:
        if type(elem) is list:
            s += format_summary_list(elem, indent + 1)
        elif type(elem) is dict:
            s += format_summary_dict(elem, indent + 1)
        else:
            s += format_summary_other(elem, indent + 1)

def format_summary_other(o, indent):
    s = ""
    s = "\t" * indent
    s += ("\n" + "\t" * indent).join(str(o).split("\n"))
    s += "\n"
    return s

def format_summary_dict(d, indent=0):
    s = ""
    for key in d:
        s += "\t" * indent + key + ":\n"
        if type(d[key]) is list:
            s += format_summary_list(d[key], indent + 1)
        elif type(d[key]) is dict:
            s += format_summary_dict(d[key], indent + 1)
        else:
            s += format_summary_other(d[key], indent + 1)
    return s

def format_summary(summary):
    scrubbed_summary = {}
    for key in summary:
        elem = summary[key]
        if elem["status"] == "not started":
            continue
        scrubbed_summary[key] = elem

    return format_summary_dict(scrubbed_summary)


def main():
    parser = argparse.ArgumentParser()

    action_group = parser.add_mutually_exclusive_group()

    action_group.add_argument("--run", "-r", nargs="+", default=None,
            help="List one or more tasks to execute")

    action_group.add_argument("--list", "-l",
            default=False, action="store_true")

    action_group.add_argument("--visualize", "-s", nargs="*",
            default=None)

    action_group.add_argument("--clean", "-c", nargs="*",
            default=None)

    sudo_group = parser.add_mutually_exclusive_group()

    sudo_group.add_argument("--sudo_password", "-p", default=None,
                            help="Specify password for sudo as an argument")

    sudo_group.add_argument("--sudo_file", "-f", default=None,
                            help="Specify a file which contains the " +
                            "password for sudo.")

    parser.add_argument("--write_summary", "-w", default=None,
                        help="Specify a JSON file to write summary to.")

    parser.add_argument("--print_summary", "-n", default=False,
                        action="store_true", help="Display summary to " +
                        "standard out.")

    args = parser.parse_args()

    sudo_pw = None
    if args.sudo_password is not None:
        sudo_pw = args.sudo_password
    elif args.sudo_file is not None:
        with open(args.sudo_file, 'r') as f:
            sudo_pw = f.read()

    base_dir = os.path.dirname(os.path.realpath(__file__))
    tasks_dir = os.path.join(base_dir, "tasks")

    tasks = index_tasks(tasks_dir)

    if args.list:
        sys.stdout.write("\n".join(tasks.keys()))
        sys.stdout.write("\n")
        sys.stdout.flush()
        exit(0)

    if args.visualize is not None:
        master = Task("__master__", [])

        if len(args.visualize) == 0:
            master.require_task = list(tasks.keys())
        else:
            master.require_task = args.visualize

        master.hydrate(tasks)

        sys.stdout.write("digraph G {\n")
        sys.stdout.write(master.generate_graphviz())
        sys.stdout.write("}\n")

    if args.clean is not None:
        master = Task("__master__", [])

        if len(args.clean) == 0:
            master.require_task = list(tasks.keys())
        else:
            master.require_task = args.clean

        master.hydrate(tasks)
        master.clean()

    if args.run is not None:
        master = Task("__master__", [])
        master.require_task = args.run

        master.hydrate(tasks)

        master.execute(sudo_pw=sudo_pw)

        summary = generate_summary(tasks)

        if args.write_summary is not None:
            with open(args.write_summary, "w") as f:
                json.dump(summary, f, indent=4)

        if args.print_summary:
            sys.stdout.write(format_summary(summary))


if __name__ == "__main__":
    main()
