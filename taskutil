#!/usr/bin/env python3

import argparse
import sys
import os
import pathlib
import json
import subprocess
import pprint
import re
import traceback
import shutil
import stat
import urllib.request
import getpass

class TaskError(Exception):
    pass

class Task:

    def __init__(this, provides, manifest):

        this.provides = provides
        this.manifest = manifest

        this.manifest.append("task.json")

        this.status = "not started"
        this.result = {}
        this.require_task = []
        this.run_script = []
        this.require_uname = None
        this.copy_file = []
        this.mark_executable = []
        this.require_git = []
        this.require_http = []
        this.require_github = []
        this.require_sudo = True

        this.env = {}
        this.env["HOME"] = os.path.expanduser("~")
        this.env["BIN_DIR"] = os.path.join(this.env["HOME"], "bin")
        this.env["TASK_DIR"] = os.getcwd()

    def do_copy_file(this):
        if len(this.copy_file) == 0:
            return

        results = {}
        for cp in this.copy_file:
            src = cp[0].format(**this.env)
            dest = cp[1].format(**this.env)
            rn = "Copy file '{}' to '{}'".format(src, dest)
            try:
                shutil.copyfile(src, dest)
                results[rn] = "Copy finished ok."
            except Exception as e:
                this.status = "failed"
                results[rn] = str(e)

        this.result["copy-file"] = results

    def do_require_github(this):
        for g in this.require_github:
            url, clonedir, branch = g
            fullurl = "https://github.com/{}.git".format(url)
            print(fullurl)
            this.require_git = [[fullurl, clonedir, branch], *this.require_git]

    def do_require_http(this):
        if len(this.require_http) == 0:
            return

        results = {}
        for h in this.require_http:
            url, dest = h
            dest = dest.format(this.env)
            rn = "Download file '{}' to '{}'".format(url, dest)
            try:
                urllib.request.urlretrieve(url, dest)
                results[rn] = "Download ok."
            except Exception as e:
                this.status = "failed"
                results[rn] = str(e)

        this.result["require-http"] = results

    def do_require_git(this):
        if len(this.require_git) == 0:
            return

        results = {}
        for g in this.require_git:
            os.chdir(this.env["TASK_DIR"])
            url, clonedir, branch = g
            rn = "Clone git repository '{}' on branch '{}' to '{}'" \
                    .format(url, branch, clonedir)
            results[rn] = "\n"
            if not os.path.exists(clonedir):
                results[rn] = "$ git clone {} {}\n".format(url, clonedir)
                try:
                    result = subprocess.check_output(
                            ["git", "clone", url, clonedir],
                            stderr=subprocess.PIPE)
                    result = result.decode("utf-8")
                    result = result.strip()
                    results[rn] += result + "\n"
                except Exception as e:
                    results[rn] += str(e)
                    this.status = "failed"
                    continue

            os.chdir(clonedir)

            try:
                results[rn] += "$ git checkout {}\n".format(branch)
                result = subprocess.check_output(
                        ["git", "checkout", branch],
                        stderr=subprocess.PIPE)
                result = result.decode("utf-8")
                result = result.strip()
                results[rn] += result + "\n"

                results[rn] += "$ git reset --hard HEAD\n"
                result = subprocess.check_output(
                        ["git", "reset", "--hard", "HEAD"],
                        stderr=subprocess.PIPE)
                result = result.decode("utf-8")
                result = result.strip()
                results[rn] += result + "\n"


            except Exception as e:
                results[rn] += str(e)
                this.status = "failed"
                continue

            try:

                results[rn] += "$ git pull origin {}\n".format(branch)
                result = subprocess.check_output(
                        ["git", "pull", "origin", branch],
                        stderr=subprocess.PIPE)
                result = result.decode("utf-8")
                result = result.strip()
                results[rn] += result + "\n"

            except Exception as e:
                results[rn] += "\nFailed to pull origin. Failure is non"
                results[rn] += "-fatal to task completion.\n"

        gitignore = os.path.join(this.env["TASK_DIR"], ".gitignore")
        if not os.path.exists(gitignore):
            with open(gitignore, "w") as f:
                for g in this.require_git:
                    url, clonedir, branch = g
                    f.write(clonedir)
                    f.write("\n")


        this.result["require-git"] = results

    def do_mark_executable(this):
        if len(this.mark_executable) == 0:
            return

        results = {}
        for mx in this.mark_executable:
            mx = mx.format(**this.env)
            rn = "Mark file '{}' executable".format(mx)
            try:
                st = os.stat(mx)
                os.chmod(mx, st.st_mode | stat.S_IXUSR | stat.S_IXGRP |
                        stat.S_IXOTH)
                results[rn] = "Chmod finished ok."
            except Exception as e:
                this.status = "failed"
                results[rn] = str(e)

        this.result["mark-executable"] = results

    def do_run_script(this):
        if len(this.run_script) == 0:
            return

        os.chdir(this.env["TASK_DIR"])

        scriptenv = { ** os.environ }
        for k in this.env:
            scriptenv["TASKUTIL_"+k] = this.env[k]

        results = {}
        for cmd in this.run_script:
            try:
                result = subprocess.check_output(cmd,
                        env=scriptenv, stdin=subprocess.DEVNULL,
                        stderr=subprocess.PIPE)
                result = result.decode("utf-8")
                result = result.strip()
                results[str(cmd)] = result
            except subprocess.CalledProcessError as e:
                results[str(cmd)] = str(e)
                results[str(cmd)] += "\n- - - stdout - - -\n"
                results[str(cmd)] += e.output.decode("utf-8")
                results[str(cmd)] += "\n- - - stderr - - -\n"
                results[str(cmd)] += e.stderr.decode("utf-8")
                this.status = "failed"

            except Exception as e:
                results[str(cmd)] = str(e)
                this.status = "failed"

        this.result["run-script"] = results

    def do_require_uname(this):
        if this.require_uname is None:
            return

        uname_regex = re.compile(this.require_uname)
        uname = subprocess.check_output(["uname"]).decode("utf-8").strip()
        if not uname_regex.match(uname):
            this.result["require-uname"] = \
                    "Uname '{}' did not match regext {}'".format(
                        uname, this.require_uname)
            this.status = "failed"
        else:
            this.result["require-uname"] = \
                    "Uname '{}' matched regex '{}'".format(
                        uname, this.require_uname)

    def generate_graphviz(this):
        s = '\t"{}";\n'.format(this.provides)
        for t in this.require_task:
            s += t.generate_graphviz()
        for t in this.require_task:
            s += '\t"{}" -> "{}";\n'.format(this.provides, t.provides)
        return s

    def hydrate(this, tasks):
        for i in range(len(this.require_task)):
            if type(this.require_task[i]) is str:
                if this.require_task[i] not in tasks:
                    sys.stderr.write("FATAL: unknown task '{}'\n"
                            .format(this.require_task[i]))
                    raise TaskError()
                this.require_task[i] = tasks[this.require_task[i]]
            this.require_task[i].hydrate(tasks)

    def execute(this, sudo_pw=None):

        # ensure we have the sudo password if we need it
        if this.require_sudo:
            if (sudo_pw is None) and (not sys.stdin.isatty()):
                this.status = "failed"
                this.result["require-sudo"] = "Task requires sudo and " + \
                    "no sudo password was provided"
            elif sudo_pw is None:
                sudo_pw = getpass.getpass("Sudo password is required: ")

            this.env["SUDO_PASSWORD"] = sudo_pw

        # ensure all dependencies are satisfied
        for task in this.require_task:
            if task.status == "not started":
                task.execute(sudo_pw=sudo_pw)

            if task.status == "failed":
                this.status = "failed"
                if "require-task" not in this.result:
                    this.result["require-task"] = {}
                this.result["require-task"][task.provides] = \
                        "Task '{}' reported itself to be in failure state" \
                        .format(task.provides)

        if this.status != "failed":
            os.chdir(this.env["TASK_DIR"])
            this.do_require_uname()
            this.do_require_github()
            this.do_require_git()
            this.do_require_http()
            this.do_copy_file()
            this.do_mark_executable()
            this.do_run_script()


        if this.status != "failed":
            this.status = "complete"

    def get_result_summary(this):
        s = "{}: {}\n".format(this.provides, this.status)
        for k in this.result:
            s += "\t{}: ".format(k)
            if type(this.result[k]) is str:
                s += '\n\t\t'.join(this.result[k].split('\n'))
                s += "\n"
            elif type(this.result[k]) is list:
                s += "\n"
                for li in this.result[k]:
                    s += "\t\t{}\n".format(li)
            elif type(this.result[k]) is dict:
                s += "\n"
                for ik in this.result[k]:
                    if type(this.result[k]) is str:
                        s += '\n\t\t\t'.join(this.result[k].split('\n'))
                        s += "\n"
                    elif type(this.result[k]) is list:
                        s += "\n"
                        for li in this.result[k]:
                            s += "\t\t\t{}\n".format(li)
                    else:
                        s += "\t\t{}: ".format(ik)
                        s += '\n\t\t\t'.join(
                                str(this.result[k][ik]).split('\n'))
                        s += "\n"
            else:
                s += '\n\t\t'.join(str(this.result[k]).split('\n'))
                s += "\n"

        s += "\n"

        for t in this.require_task:
            s += t.get_result_summary()

        return s

    def clean(this):
        dirstack = []
        for p in pathlib.Path(this.env["TASK_DIR"]).glob("./**/*"):

            if this.provides == "__master__":
                # should never be directly cleaning files under __master__
                # because it points to the taskutil install dir.
                break

            delete = True
            for m in this.manifest:
                m = os.path.join(this.env["TASK_DIR"], m)
                if os.path.normpath(p) == os.path.normpath(m):
                    sys.stderr.write("protected: {}\n".format(m))
                    delete = False

            if delete:
                if os.path.isfile(p):
                    sys.stderr.write("removing: {}\n".format(p))
                    os.remove(p)
                else:
                    dirstack.append(p)

        # we try to delete everything many times in case there are nested
        # sub-directories
        for i in range(len(dirstack)):
            for p in dirstack:
                    try:
                        os.rmdir(p)
                    except Exception as e:
                        pass

        for p in dirstack:
            if not os.path.exists(p):
                continue

            try:
                os.rmdir(p)
            except Exception as e:
                print_warning("Could not delete '{}': {}".format(p, e))

        for r in this.require_task:
            r.clean()

    def __str__(this):
        return "{}: {}".format(this.provides, this.status)


def print_warning(msg):
    sys.stderr.write("WARNING: {}\n".format(msg))
    sys.stderr.flush()

def index_tasks(taskstore):
    pathlist = pathlib.Path(taskstore).glob("*/task.json")
    tasks = {}
    for p in pathlist:
        with open(str(p), 'r') as f:
            j = json.load(f)
            name = j["provides"]
            if 'provides' not in j:
                print_warning("taskfile is missing 'provides' field: {}"
                              .format(p))
                continue
            if 'manifest' not in j:
                print_warning("taskfile is missing 'manifest' field: {}"
                              .format(p))
                continue
            if name in tasks:
                print_warning("duplicate provider for '{}' in: {}"
                              .format(name, p))
                continue

            task = Task(name, j["manifest"])

            task.env["TASK_DIR"] = os.path.dirname(p)

            if 'require-task' in j:
                task.require_task = j["require-task"]

            if 'run-script' in j:
                task.run_script = j["run-script"]

            if 'require-uname' in j:
                task.require_uname = j["require-uname"]

            if 'copy-file' in j:
                task.copy_file = j["copy-file"]

            if 'mark-executable' in j:
                task.mark_executable = j["mark-executable"]

            if 'require-git' in j:
                task.require_git = j["require-git"]

            if 'require-github' in j:
                task.require_github = j["require-github"]

            if 'require-http' in j:
                task.require_http = j["require-http"]

            if 'require-sudo' in j:
                task.require_sudo = j["require-sudo"]

            tasks[name] = task

    return tasks



def main():
    parser = argparse.ArgumentParser()

    action_group = parser.add_mutually_exclusive_group()

    action_group.add_argument("--run", "-r", nargs="+", default=None,
            help="List one or more tasks to execute")

    action_group.add_argument("--list", "-l",
            default=False, action="store_true")

    action_group.add_argument("--visualize", "-s", nargs="*",
            default=None)

    action_group.add_argument("--clean", "-c", nargs="*",
            default=None)

    sudo_group = parser.add_mutually_exclusive_group()

    sudo_group.add_argument("--sudo_password", "-p", default=None,
                            help="Specify password for sudo as an argument")

    sudo_group.add_argument("--sudo_file", "-f", default=None,
                            help="Specify a file which contains the " +
                            "password for sudo.")

    args = parser.parse_args()

    sudo_pw = None
    if args.sudo_password is not None:
        sudo_pw = args.sudo_password
    elif args.sudo_file is not None:
        with open(args.sudo_file, 'r') as f:
            sudo_pw = f.read()

    base_dir = os.path.dirname(os.path.realpath(__file__))
    tasks_dir = os.path.join(base_dir, "tasks")

    tasks = index_tasks(tasks_dir)

    if args.list:
        sys.stdout.write("\n".join(tasks.keys()))
        sys.stdout.write("\n")
        sys.stdout.flush()
        exit(0)

    if args.visualize is not None:
        master = Task("__master__", [])

        if len(args.visualize) == 0:
            master.require_task = list(tasks.keys())
        else:
            master.require_task = args.visualize

        master.hydrate(tasks)

        sys.stdout.write("digraph G {\n")
        sys.stdout.write(master.generate_graphviz())
        sys.stdout.write("}\n")

    if args.clean is not None:
        master = Task("__master__", [])

        if len(args.clean) == 0:
            master.require_task = list(tasks.keys())
        else:
            master.require_task = args.clean

        master.hydrate(tasks)
        master.clean()

    if args.run is not None:
        master = Task("__master__", [])
        master.require_task = args.run

        master.hydrate(tasks)

        master.execute(sudo_pw=sudo_pw)

        sys.stdout.write(master.get_result_summary())


if __name__ == "__main__":
    main()
