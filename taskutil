#!/usr/bin/env python3

import argparse
import sys
import os
import pathlib
import json
import subprocess
import pprint
import re
import traceback

class TaskError(Exception):
    pass

class Task:

    def __init__(this, provides, manifest):

        this.provides = provides
        this.manifest = manifest

        this.status = "not started"
        this.result = {}
        this.require_task = []
        this.run_script = []
        this.require_uname = None

    def do_run_script(this):
        if len(this.run_script) == 0:
            return

        results = {}
        for cmd in this.run_script:
            try:
                result = subprocess.check_output(cmd)
                result = result.decode("utf-8")
                result = result.strip()
                results[str(cmd)] = result
            except Exception as e:
                results[str(cmd)] = str(e)
                this.status = "failed"

        this.result["run-script"] = results

    def do_require_uname(this):
        if this.require_uname is None:
            return

        uname_regex = re.compile(this.require_uname)
        uname = subprocess.check_output(["uname"]).decode("utf-8").strip()
        if not uname_regex.match(uname):
            this.result["require-uname"] = \
                    "Uname '{}' did not match regext {}'".format(
                        uname, this.require_uname)
            this.status = "failed"
        else:
            this.result["require-uname"] = \
                    "Uname '{}' matched regex '{}'".format(
                        uname, this.require_uname)

    def generate_graphviz(this):
        s = '\t"{}";\n'.format(this.provides)
        for t in this.require_task:
            s += t.generate_graphviz()
        for t in this.require_task:
            s += '\t"{}" -> "{}";\n'.format(this.provides, t.provides)
        return s

    def hydrate(this, tasks):
        for i in range(len(this.require_task)):
            if type(this.require_task[i]) is str:
                this.require_task[i] = tasks[this.require_task[i]]
            this.require_task[i].hydrate(tasks)

    def execute(this):
        # ensure all dependancies are satisfied
        for task in this.require_task:
            if task.status == "not started":
                task.execute()

            if task.status == "failed":
                this.status = "failed"
                if "require-task" not in this.result:
                    this.result["require-task"] = {}
                this.result["require-task"][task.provides] = \
                        "Task '{}' reported itself to be in failure state" \
                        .format(task.provides)

        if this.status != "failed":
            this.do_require_uname()
            this.do_run_script()

        if this.status != "failed":
            this.status = "complete"

    def get_result_summary(this):
        s = "{}: {}\n".format(this.provides, this.status)
        for k in this.result:
            s += "\t{}: ".format(k)
            if type(this.result[k]) is str:
                s += this.result[k]
                s += "\n"
            elif type(this.result[k]) is list:
                s += "\n"
                for li in this.result[k]:
                    s += "\t\t{}\n".format(li)
            elif type(this.result[k]) is dict:
                s += "\n"
                for ik in this.result[k]:
                    s += "\t\t"
                    s += str(this.result[k][ik])
            else:
                s += str(this.result[k])
                s += "\n"

        s += "\n"

        for t in this.require_task:
            s += t.get_result_summary()

        return s

    def __str__(this):
        return "{}: {}".format(this.provides, this.status)


def print_warning(msg):
    sys.stderr.write("WARNING: {}\n".format(msg))
    sys.stderr.flush()

def index_tasks(taskstore):
    pathlist = pathlib.Path(taskstore).glob("*/task.json")
    tasks = {}
    for p in pathlist:
        with open(str(p), 'r') as f:
            j = json.load(f)
            name = j["provides"]
            if 'provides' not in j:
                print_warning("taskfile is missing 'provides' field: {}"
                              .format(p))
                continue
            if 'manifest' not in j:
                print_warning("taskfile is missing 'manifest' field: {}"
                              .format(p))
                continue
            if name in tasks:
                print_warning("duplicate provider for '{}' in: {}"
                              .format(name, p))
                continue

            task = Task(name, j["manifest"])

            if 'require-task' in j:
                task.require_task = j["require-task"]

            if 'run-script' in j:
                task.run_script = j["run-script"]

            if 'require-uname' in j:
                task.require_uname = j["require-uname"]

            tasks[name] = task

    return tasks



def main():
    parser = argparse.ArgumentParser()

    action_group = parser.add_mutually_exclusive_group()

    action_group.add_argument("--run", "-r", nargs="+", default=None,
            help="List one or more tasks to execute")

    action_group.add_argument("--list", "-l",
            default=False, action="store_true")

    action_group.add_argument("--visualize", "-s", nargs="*",
            default=None)

    args = parser.parse_args()

    base_dir = os.path.dirname(os.path.realpath(__file__))
    tasks_dir = os.path.join(base_dir, "tasks")

    tasks = index_tasks(tasks_dir)

    if args.list:
        sys.stdout.write("\n".join(tasks.keys()))
        sys.stdout.write("\n")
        sys.stdout.flush()
        exit(0)

    if args.visualize is not None:
        master = Task("__master__", [])

        if len(args.visualize) == 0:
            master.require_task = list(tasks.keys())
        else:
            master.require_task = args.visualize

        master.hydrate(tasks)

        sys.stdout.write("digraph G {\n")
        sys.stdout.write(master.generate_graphviz())
        sys.stdout.write("}\n")

    if args.run is not None:
        master = Task("__master__", [])
        master.require_task = args.run

        master.hydrate(tasks)

        master.execute()

        sys.stdout.write(master.get_result_summary())


if __name__ == "__main__":
    main()
