#!/usr/bin/env python3

import argparse
import sys
import os
import pathlib
import json
import subprocess
import pprint
import re
import traceback

class TaskError(Exception):
    pass

def print_warning(msg):
    sys.stderr.write("WARNING: {}\n".format(msg))
    sys.stderr.flush()

def index_tasks(taskstore):
    pathlist = pathlib.Path(taskstore).glob("*/task.json")
    tasks = {}
    for p in pathlist:
        with open(str(p), 'r') as f:
            j = json.load(f)
            name = j["provides"]
            if 'provides' not in j:
                print_warning("taskfile is missing 'provides' field: {}"
                              .format(p))
                continue
            if 'manifest' not in j:
                print_warning("taskfile is missing 'manifest' field: {}"
                              .format(p))
                continue
            if name in tasks:
                print_warning("duplicate provider for '{}' in: {}"
                              .format(name, p))
                continue

            j["status"] = "not started"
            j["results"] = {}

            if "require-task" not in j:
                j["require-task"] = []

            tasks[name] = j

    return tasks

def run_script(task):
    results = {}
    for cmd in task["run-script"]:
        result = subprocess.check_output(cmd)
        result = result.decode("utf-8")
        result = result.strip()
        results[str(cmd)] = result
    return results

def require_uname(task):
    uname_regex = re.compile(task["require-uname"])
    uname = subprocess.check_output(["uname"]).decode("utf-8").strip()
    if not uname_regex.match(uname):
        raise TaskError("Uname '{}' did not match '{}'"
                .format(uname, task["require-uname"]))
    else:
        return ["Uname '{}' matched regex '{}'".format(
                    uname, task["require-uname"])]

def run_task(tasks, target_task):

    task = tasks[target_task]

    fieldhandlers = {
        "run-script": run_script,
        "require-uname": require_uname,
    }

    ignore_fields = [
        "provides",
        "manifest",
        "results",
        "status",
        "require-task"
    ]

    # we assume the caller has only tried to run this task if it's status is
    # either queued or pending
    task["status"] = "queued"

    # dependency resolution
    for t in task["require-task"]:
        # if any dependency has failed, this task also fails
        if tasks[t]["status"] == "failed":
            task["status"] = "failed"
            task["results"] = "Dependency '{}' failed".format(t)
            tasks[target_task] = task
            return tasks
        # if if the dependency status is not started, queue it
        elif tasks[t]["status"] == "not started":
            task["status"] = "pending"
            tasks[t]["status"] = "queued"

    # we are still waiting on our dependencies to finish
    if task["status"] == "pending":
        tasks[target_task] = task
        return tasks

    for k in task.keys():
        if k in ignore_fields:
            continue

        if k not in fieldhandlers:
            print_warning("No handler for field '{}' in task '{}'."
                          .format(k, task["provides"]))
        else:
            try:
                task["results"][k] = fieldhandlers[k](task)
                task["status"] = "done"
            except Exception as e:
                task["results"][k] = str(e) + "\n" + traceback.format_exc()
                task["status"] = "failed"
                break

    tasks[target_task] = task
    return tasks

def dispatch_tasks(tasks):
    while (number_pending(tasks) + number_queued(tasks)) > 0:
        for t in tasks:
            if (tasks[t]["status"] == "queued") or \
               (tasks[t]["status"] == "pending"):
                tasks = run_task(tasks, t)

    return tasks

def format_failed(tasks):
    s = ""
    for t in tasks:
        if tasks[t]["status"] == "failed":
            s += "task '{}' failed:\n".format(tasks[t]["provides"])
            s += pprint.pformat(tasks[t]["results"])

    return s

def format_summary(tasks):
    return "\n".join(["{}: {}"
        .format(tasks[t]["provides"], tasks[t]["status"]) for t in tasks
        if tasks[t]["status"] != "not started"]) + "\n"

def number_queued(tasks):
    return len([t for t in tasks if tasks[t]["status"] == "queued"])

def number_pending(tasks):
    return len([t for t in tasks if tasks[t]["status"] == "pending"])

def main():
    parser = argparse.ArgumentParser()

    action_group = parser.add_mutually_exclusive_group()

    action_group.add_argument("--run", "-r", nargs="+", default=None,
            help="List one or more tasks to execute")

    action_group.add_argument("--list", "-l",
            default=False, action="store_true")

    parser.add_argument("--dump_tasks", default=False, action="store_true",
            help="Dump all task data to the console.")

    parser.add_argument("--summarize", "-s", default=False,
                        action="store_true", help="Display a summary " +
                        "of task execution.")

    args = parser.parse_args()

    base_dir = os.path.dirname(os.path.realpath(__file__))
    tasks_dir = os.path.join(base_dir, "tasks")

    tasks = index_tasks(tasks_dir)

    if args.list:
        sys.stdout.write("\n".join(tasks.keys()))
        sys.stdout.write("\n")
        sys.stdout.flush()
        exit(0)

    if args.run is not None:
        for t in args.run:
            if t not in tasks:
                print_warning("Task '{}' is unknown.".format(T))
                continue
            tasks[t]["status"] = "queued"

    tasks = dispatch_tasks(tasks)


    if args.dump_tasks:
        pp = pprint.PrettyPrinter()
        pp.pprint(tasks)
    elif args.summarize:
        sys.stderr.write(format_summary(tasks))
    else:
        sys.stderr.write(format_failed(tasks))


    exit(len(format_failed(tasks)))


if __name__ == "__main__":
    main()
