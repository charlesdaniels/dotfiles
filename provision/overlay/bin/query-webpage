#!/usr/bin/env python3

# Copyright 2018 Charles Daniels

#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions are met:

#  1. Redistributions of source code must retain the above copyright notice,
#  this list of conditions and the following disclaimer.

#  2. Redistributions in binary form must reproduce the above copyright notice,
#  this list of conditions and the following disclaimer in the documentation
#  and/or other materials provided with the distribution.

#  3. Neither the name of the copyright holder nor the names of its
#  contributors may be used to endorse or promote products derived from this
#  software without specific prior written permission.

#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
#  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
#  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
#  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
#  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#  POSSIBILITY OF SUCH DAMAGE.

descr = """Script to download the contents of a webpage, then print the results
of a specified xPath query and exit."""

import argparse
import urllib.request
import urllib
import lxml.etree
import sys

parser = argparse.ArgumentParser(description=descr)

parser.add_argument("--url", "-u", help="Specify target URL.", required=True)

parser.add_argument("--query", "-q", help="Specify xPath query.",
                    required=True)

parser.add_argument("--extract_content", "-e", default=False,
                    action="store_true", help="Display content only as " +
                    "output, rather than HTML markup")

parser.add_argument("--output_separator", "-s", default="\n",
                    help="Change string used to delimit matches to query in " +
                    "the output. (default: single newline)")

parser.add_argument("--disable_separator_expansion", "-E", default=False,
                    action="store_true", help="If asserted, escape " +
                    "sequences such as \\n found within the string supplied" +
                    " in --output_separator will not be expanded.")

parser.add_argument("--encoding", "-n", default="utf-8",
                    help="Specify string encoding to use where applicable." +
                    " (default: utf-8)")

parser.add_argument("--noexpand", "-x" , default=False, action="store_true",
                    help="Assert to avoid expanding control characters " +
                    "such as \\n wherever possible.")

parser.add_argument("--quiet", "-t", default=False, action="store_true",
                    help="Suppress all warning and error messagse")

args = parser.parse_args()

# This allows the user to specify escape codes like \n within
# --output_separator
if not args.disable_separator_expansion:
    args.output_separator = bytes(args.output_separator, "utf-8")
    args.output_separator = args.output_separator.decode("unicode_escape")


def show_warning(msg):
    if not args.quiet:
        sys.stderr.write("WARNING: {}\n".format(msg))

    sys.stderr.flush()

def show_error(msg):
    if not args.quiet:
        sys.stderr.write("ERROR: {}\n".format(msg))

    sys.stderr.flush()
    sys.stdout.flush()
    exit(1)

try:
    handle = urllib.request.urlopen(args.url)
except urllib.error.URLError as e:
    show_error("Failed to open URL. Exception was: '{}'.".format(e))

try:
    tree = lxml.etree.HTML(handle.read())
except Exception as e:
    show_error("Failed to parse webpage. Exception was: '{}'.".format(e))

handle.close()

try:
    results = tree.xpath(args.query)
except Exception as e:
    show_error("Query failed. Exception was: '{}'.".format(e))

for r in results:

    if args.extract_content:
        if r.text is None:
            # Sometimes we find an element with no visible text, in which case
            # we can't really do much of anything.
            show_warning("Ignored element '{}' because it had empty .text."
                         .format(r))
            continue
        sys.stdout.write(r.text)

    else:
        text = lxml.etree.tostring(r, pretty_print=True)
        try:
            text = text.decode(args.encoding)
        except Exception as e:
            show_error("Failed to decode text. Exception was: '{}'.".format(e))

        if args.noexpand:
            text = "%r" % text
            # this removes the leading and trailing single quotes introduced
            # by the %r in the above statement.
            text = text[1:-1]
        sys.stdout.write(text)

    sys.stdout.write(args.output_separator)

sys.stdout.flush()
