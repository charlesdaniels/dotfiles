#!/bin/sh

# .SCRIPTDOC

# This script is used to hook other scripts that need to run under various
# conditions, and which I have not found better hooks for. This is highly
# specific to my setup, and probably will be of minimal use to anyone else.

# This script runs a loop every $DESKTOP_SPOOLER_INTERVAL. When this loop runs,
# it polls lsusb to see if any of the USB device IDs specified in
# ~/.dspool/dock_devices.txt exist, using this information to populate
# $DOCK_STATE. If $DOCK_STATE changes, the script restore-sanity is executed,
# and the file $DOCK_SPOOLER_DIR/dock_status is updated.

# .LICENSE

# Copyright 2018, Charles A. Daniels
# This software is distributed under the BSD 3-clause license. The full text
# of this software's license may be retrieved from this URL:
# https://github.com/charlesdaniels/dotfiles/blob/master/LICENSE

# .ENDOC

set -u

log_msg () {
	MSG="$(timestamp-message $@)"
	echo $MSG > /dev/stderr 2>&1
	echo $MSG >> "$LOG_FILE" 2>&1
}

DESKTOP_SPOOLER_DIR="$HOME/.dspool"
DESKTOP_SPOOLER_INTERVAL=5
DOCK_DEVICE_LIST="$DESKTOP_SPOOLER_DIR/dock_devices.txt"
LOG_FILE="$DESKTOP_SPOOLER_DIR/log"

if [ ! -d "$DESKTOP_SPOOLER_DIR" ] ; then
	log_msg "INFO" "Spooler directory '$DESKTOP_SPOOLER_DIR' does not exist, creating it..."
	mkdir -p "$DESKTOP_SPOOLER_DIR"
fi

if [ ! -d "$DESKTOP_SPOOLER_DIR" ] ; then
	log_msg "ERROR" "spooler dir '$DESKTOP_SPOOLER_DIR' does not exist and creating it failed."
	exit 1
fi

		else
PREV_DOCK_STATE=""
DOCK_STATE=""
PREV_MONITOR_STATE=""
MONITOR_STATE=""
HID_STATE=""
PREV_HID_STATE=""

SCREENLAYOUT_DIR=$HOME/.screenlayout

# keep the log file from overflowing
mv "$LOG_FILE" "$LOG_FILE.prev"

while true ; do
	DOCK_STATE="UNDOCKED"
	while read -r DOCK_DEVICE < "$DOCK_DEVICE_LIST" ; do
		if lsusb | grep "$DOCK_DEVICE" > /dev/null 2>&1 ; then
			DOCK_STATE="DOCKED"
			break
		fi
	done

	if [ "$DOCK_STATE" = "$PREV_DOCK_STATE" ] ; then
		# do nothing
		printf ""
	else
		# this else runs on any dock state change
		if [ "$DOCK_STATE" = "DOCKED" ] ; then
			# this implies we have gone from undocked to docked
			for layout in "$SCREENLAYOUT_DIR"/$(hostname).docked.screenlayout.*.sh ; do
				log_msg "INFO" "attempting to execute screenlayout file '$layout'"
				if sh "$layout" > /dev/null 2>&1 ; then
					log_msg "INFO" "layout configuration succeeded"
					break
				else
					log_msg "INFO" "layout configuration failed"
				fi
			done
		fi

		if [ "$DOCK_STATE" = "UNDOCKED" ] ; then
			# this implies we have gone from docked to undocked
			for layout in "$SCREENLAYOUT_DIR"/$(hostname).undocked.screenlayout.*.sh ; do
				log_msg "INFO" "attempting to execute screenlayout file '$layout'"
				if sh "$layout" ; then
					log_msg "INFO" "layout configuration succeeded"
					break
				else
					log_msg "INFO" "layout configuration failed"
				fi
			done
		fi

		# handle dock / undock events
		log_msg "INFO" "dock state $PREV_DOCK_STATE -> $DOCK_STATE"
		restore-sanity # reset wallpaper and reload xmodmap
		# write new dock state to status file for i3bar
		printf "$DOCK_STATE" > "$DESKTOP_SPOOLER_DIR/dock_status"
		sleep 2
		# run it again in case any USB devices have been enumerated
		# since we docked
		restore-sanity
		sleep 1

		# configure-dpms will detect if the new state is docked or
		# undocked.
		configure-dpms >> "$LOG_FILE"
		tail -n 1 "$LOG_FILE" > /dev/stderr


	fi

	PREV_DOCK_STATE="$DOCK_STATE"

	MONITOR_STATE="$(xrandr | shasum)"
	if [ "$MONITOR_STATE" != "$PREV_MONITOR_STATE" ] ; then
		# fix wallpaper on monitor state change
		log_msg "INFO" "monitor state changed"
		restore-sanity
	fi
	PREV_MONITOR_STATE="$MONITOR_STATE"

	HID_STATE="$(lsusb -t | grep -i 'human interface' | cut -d_ -f 3 | shasum)"
	if [ "$HID_STATE" != "$PREV_HID_STATE" ] ; then
		# fix xmodmap bindings on HID state change
		log_msg "INFO" "HID state changed"
		restore-sanity
	fi
	PREV_HID_STATE="$HID_STATE"


	sleep $DESKTOP_SPOOLER_INTERVAL
done
